---
title: work with groups
---

```{julia}
#| echo: false
#| code-fold: true
#| output: false
using Pkg;
cd(@__DIR__)
Pkg.activate("."); # for reproducibility use the local tutorial environment.
Pkg.develop(path="../") # a trick to work on the local dev version
using Markdown
```

This is a short overview of group support in [`Manifolds.jl`](https://juliamanifolds.github.io/Manifolds.jl/) and how to get started working with them.

Groups currently available in `Manifolds.jl` are listed in ``[group section](@ref GroupManifoldSection)``{=commonmark}.

You can read more about the theory of Lie groups for example in [Chirikjian:2012](@cite).
An example application of Lie groups in robotics is described in [SolaDerayAtchuthan:2021](@cite).

First, let's load libraries we will use.
`RecursiveArrayTools` is necessary because `ArrayPartition` defined in it is used as one of the possible representations of elements of product and semidirect product groups.

```{julia}
using Manifolds, RecursiveArrayTools
```

## Introduction: group of rotations on a plane

Let's first consider an example of the group of rotations of a plane, $\operatorname{SO}(2)$.
They can be represented in several ways, for example as angles of rotation (which corresponds to [`RealCircleGroup`](@ref)), unit complex numbers ([`CircleGroup`](@ref)), or rotation matrices ([`SpecialOrthogonal`](@ref)).
Let's consider the last representation since it is the most nontrivial one and can be more easily generalized to other groups.

The associated manifolds and groups are defined by:

```{julia}
G = SpecialOrthogonal(2)
M = base_manifold(G)
@assert M === Rotations(2)
```

This duality (Lie group and the underlying manifold being separate) is a common pattern in `Manifolds.jl`. The group `G` can be used for both Lie group-specific operations and metric-specific operation, while the manifold `M` only allows using manifold and metric operations. This way groups can be specialized in ways not relevant to plain manifolds, and if someone doesn't use the groups structure, they don't have to consider it by just using the manifold.

Some basic definitions

```{julia}
# default basis
B = DefaultOrthogonalBasis()
# Identity rotation
p0 = @SMatrix [1.0 0; 0 1]

# Group identity element of a special type
IG = Identity(G)
```


Let's say we want to define a manifold point `p_i` some rotation Œ∏ from the [`identity`](@ref) reference rotation `p0` (another point on the manifold that we will use as reference)

```{julia}
# + radians rotation from x-axis on plane to point i
xŒ∏i = œÄ/6
```

### From Coordinates

To get our first Lie algebra element we can use the textbook [`hat`](@ref), or equivaliently a more generalized [`get_vector`](@ref), function:

```{julia}
X_ = hat(G, IG, xŒ∏i)              # specific definition to Lie groups
xXi = get_vector(G, IG, xŒ∏i, B)   # generalized definition beyond Lie groups
println(xXi)
@assert isapprox( X_, xXi )
```

Note that `hat` here assumes a default (orthogonal) basis for the more general `get_vector`.

::: {.callout-note}
In this case, the same would work given the base manifold [`Rotations(2)`](@ref):
```{julia}
_X_ = hat(M, xR0, xŒ∏i)             # Lie groups definition
_X = get_vector(M, xR0, xŒ∏i, B)   # generalized definition
@assert _X_ == xXi; @assert _X == xXi
```
One more caveat here is that for the Rotation matrices, the tangent vectors are always stored as elements from the Lie algebra.
:::

Now, let's place this algebra element on the manifold using the exponential map [`exp`](@ref):
```{julia}
xRi = exp(G, xR0, xXi)
# similarly for known underlying manifold
xRi_ = exp(M, xR0, xXi)

@assert isapprox( xRi, xRi_ )
```

### To Coordinates

The logarithm transform from the group back to algebra (or coordinates) is:
```{julia}
xXi_ = log(G, xR0, xRi)
xXi__ = log(M, xR0, xRi)
@assert xXi == xXi__
```

Similarly, the coordinate value can be extracted from the algebra using [`vee`](@ref), or directly from the group using the more generalized [`get_coordinates`](@ref):

```{julia}
# extracting coordinates using vee
xŒ∏i__ = vee(G, xR0, xXi_)[1]
_xŒ∏i__ = vee(M, xR0, xXi_)[1]

# OR, the preferred generalized get_coordinate function
xŒ∏i_ = get_coordinates(G, xR0, xXi_, B)[1]
_xŒ∏i_ = get_coordinates(M, xR0, xXi_, B)[1]

# confirm all versions are correct
@assert isapprox( xŒ∏i, xŒ∏i_ ); @assert isapprox( xŒ∏i, _xŒ∏i_ )
@assert isapprox( xŒ∏i, xŒ∏i__ ); @assert isapprox( xŒ∏i, _xŒ∏i__ )
```  

::: {.callout-note}
The disadvantage might be that the representation of `X` is not nice, i.e. it uses too much space or doing vector-calculations is not so easy.  E.g. fixed rank matrices are overloaded for all vector operations, but maybe that is ‚Äúnot enough‚Äù for a general user application that really wants vectors. But: Given a basis `B` one can look at the coefficients of the tangent vector `X` with respect to basis `B`.  From the Sphere example note above the basis vectors would be `Y1=[0.0, 1.0, 0.0]` and `Y2=[0.0, 0.0, 1.0]`, so to get the coordinates would be `c = get_coordinates(Sphere(2), p, X, B)`.  Vice versa, if you have a coordinate vector with respect to a basis `B` of the tangent space at `p` and want the vector back, then you do `X2 = get_vector(M, p, c, B)` (and you should have `X2==X`).  The coordinate vector `c` might also have the advantage of saving memory. For example SPD matrix tangent vectors take $n^2$ entries to save, i.e. storing the full matrix, but the coordinate vectors only take $\frac{n(n+1)}{2}$.
:::

## Relationship between groups, metrics and connections

Group structure provides a canonical way to define [üìñ exponential](https://en.wikipedia.org/wiki/Exponential_map_(Lie_theory)) and üìñ logarithmic maps from the Lie algebra.
They can be calculated in `Manifolds.jl` using the [`exp_lie`](@ref) and [`log_lie`](@ref) functions. Such exponential and logarithmic maps can be extended invariantly to tangent spaces at any point of the Lie group. This extension is implemented using functions [`exp_inv`](@ref) and [`log_inv`](@ref).

Finally, there are `log` and `exp` functions which are metric (or connection)-related functions in `Manifolds.jl`. For groups which can be equipped with a bi-invariant metric, `log` and `log_inv` return the same result, similarly `exp` and `exp_inv`. However, only compact groups and their products with Euclidean spaces can have a bi-invariant metric (see for example Theorem 21.9 in [GallierQuaintance:2020](@ref)). A prominent example of a Lie group without a bi-invariant metric is the special Euclidean group (in two or more dimensions). Then we have a choice between a metric but non-invariant exponential map (which is generally the default choice for `exp`) or a non-metric, invariant exponential map (`exp_inv`). Which one should be used depends on whether being metric or being invariant is more important in a particular application.


## Literature

````{=commonmark}
```@bibliography
Pages = ["groups.md"]
Canonical=false
```
````